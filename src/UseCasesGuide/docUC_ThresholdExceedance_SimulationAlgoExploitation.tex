% Copyright (c)  2005-2010 EDF-EADS-PHIMECA.
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts.  A copy of the license is included in the section entitled "GNU
% Free Documentation License".
\renewcommand{\filename}{docUC_ThresholdExceedance_SimulationAlgoExploitation.tex}
\renewcommand{\filetitle}{UC : Run and results exploitation  of a simulation algorithm : probability estimation, estimator variance, confidence interval, convergence graph, stored samples}

% \HeaderNNIILevel
% \HeaderIILevel
\HeaderIIILevel


\label{simuRes}


\index{Threshold Probability!History storage strategy}

The objective of this Use Case is to launch the evaluation of the event probability with a simulation algorithm and to get all the results proposed by Open TURNS : the probability estimation, the estimator variance, the confidence interval, the convergence graph of the estimator, the stored input and output numerical samples.


\index{Random Generator}
\index{Graph Manipulation!Bounding box}
\index{Graph Manipulation!ViewImage}
\index{Graph Manipulation!Show}



Details on the simulation algorithm method may be found in the Reference Guide (\href{OpenTURNS_ReferenceGuide.pdf}{see files Reference Guide - Step C --Estimating the probability of an event using Sampling}).\\

Details on each object may be found in the User Manual  (\href{OpenTURNS_UserManual_TUI.pdf}{see User Manual - Threshold exceedance probability evaluation with simulation / Simulation Result}).\\

Before any simulation, it is possible to initialise or get the state of the random generator aqs explined in the Use Case \ref{randomGenerator}.\\

It is often usefull to evaluate the exact number of calls to the limit state function the simulation has required. One way to get it is to ask the number of times the limit state function has been evaluated so far, just before and just after the simulation algorithm run.\\
In the Monte Carlo simulation case, this number can be directly obtained by multiplying the BlockSize parameter with the OuterSampling one.\\
The following Use Case illustrates both situations.\\

It also illustrates how to  :
\begin{itemize}
\item evaluate the probability estimator $P_N$ of the real probability $p$,
\item evaluate the confidence length of level $\alpha$ around the probabilty estimator, from the formula :
  $$
  IC_\alpha = [P_N - t_{\alpha}\sqrt{\frac{P_N(1-P_N)}{N}}; P_N + t_{\alpha}\sqrt{\frac{P_N(1P_N)}{N}}]
  $$
  where $t_{\alpha} = \phi_{(0,1)}(\frac{1-\alpha}{2})$. Open TURNS evaluates the length $l$ of the confidence interval, defined as : $\displaystyle l = 2t_{\alpha}\sqrt{\frac{P_N(1-P_N)}{N}}^{\strut}$. Thus we have $Prob[p \in IC_\alpha] = \alpha$.
\item draw the convergence graph of the probability estimator, with the confidence curves,
\item get the numerical sample used all along the simulation run,
\item get the mean point  of all the simulations $ (\vect{X_i})_{(1\leq i \leq n)}$ generated by the Simulation algorithm that failed into the event domain in the physical space : 
\begin{equation}\label{meanPtSimu}
\vect{X}^*_{event} = \displaystyle \frac{1}{n} \sum_{i=1}^{i=n} \vect{X_i}1_{event}(\vect{X}_i)
\end{equation}
Be carefull : this notion is only valuable for Monte Carlo or LHS sampling as the mean is evaluated from the (\ref{meanPtSimu}) relation (only uniform weights over the realizations $\vect{X_i}$. 
\item get some importance factors estimated from the coordinates of the mean point (\ref{meanPtSimu}) mapped into the standard space :
\begin{equation}\label{impFctSimu}
\alpha_i = \displaystyle \frac{\left(U_{i}^*\right)^2}{||\vect{U}^*||^2}
\end{equation}
where 
\begin{equation}\label{meanPtSimuStdSpace}
\vect{U}^* = T(\vect{X}^*_{event})
\end{equation}
Be carefull : the same restriction as previoulsly exists.
\end{itemize}




\requirements{
  \begin{description}
  \item[$\bullet$] the simulation algorithm : {\itshape myAlgo}
  \item[type:] Simulation
  \end{description}
}
{
  \begin{description}
  \item[$\bullet$] the  probability estimation
  \item[type:] NumericalScalar
  \item[$\bullet$] Confidence Interval length
  \item[type:] NumericalScalar
  \item[$\bullet$]  Variance of the simulation probability estimator
  \item[type:] NumericalScalar
  \item[$\bullet$]  the input and output samples used during the algorithm, and the values of the probability estimator and its variance
  \item[type:] NumericalSample
  \item[$\bullet$]  the convergence graphs
  \item[type:] Graph
  \item[$\bullet$]  the  mean point in eventdoain and its importance factors
  \item[type:] NumericalPoint
  \end{description}
}

\textspace\\
Python  script for this UseCase :

\begin{lstlisting}
  # Save the number of calls to the limit state function, its gradient and hessian done so far
  # NOT usefull in the Monte Carlo case
  limitStateFunctionCallNumberBefore = limitStateFunction.getEvaluationCallsNumber()
  limitStateFunctionGradientCallNumberBefore = limitStateFunction.getGradientCallsNumber()
  limitStateFunctionHessianCallNumberBefore = limitStateFunction.getHessianCallsNumber()

  # If one wants to have access to the input and output samples
  # after the simulation, one must activate the history mechanism 
  limitStateFunction.enableHistory()
  limitStateFunction.resetHistory()

  # Launch the simulation
  myAlgo.run()

  # Save the number of calls to the limit state function, its gradient and hessian done so far
  limitStateFunctionCallNumberAfter = limitStateFunction.getEvaluationCallsNumber()
  limitStateFunctionGradientCallNumberAfter = limitStateFunction.getGradientCallsNumber()
  limitStateFunctionHessianCallNumberAfter = limitStateFunction.getHessianCallsNumber()

  # Display the number of iterations executed and
  # the number of evaluations of the limit state function
  print "number of evaluations of the limit state function = ",
  limitStateFunctionCallNumberAfter - limitStateFunctionCallNumberBefore

  # Stream out the complete simulation result structure
  result = myAlgo.getResult()

  # Get the mean point in event  domain
  # care : only for Monte Carlo and LHS sampling methods
  meanPointEvent = result.getMeanPointInEventDomain()

  # Get the associated importance factors
  # care : only for Monte Carlo and LHS sampling methods
  impFactorsSimulation =  result.getImportanceFactors()

  # Display the number of iterations executed and the number of
  # evaluations of the limit state function
  # ONLY in the Monte Carlo case
  print "number of evaluations of the limit state function = ", result.getOuterSampling()*result.getBlockSize()

  # Get the values of the stopping criteria
  # Criteria 1 : Display the Coefficient of Variation of the estimator
  print "Coefficient of Variation of Pn = ", result.getCoefficientOfVariation()

  #  Criteria 2 : Display the Outer Sampling of the simumlation
  print "Outer Sampling of the simumlation =  ", result.getOuterSampling()

  #  Criteria 3 : Display the Standard Deviation of the estimator
  print " Standard Deviation of the estimator =  ", result.getStandardDeviation()

  # Display the simulation event probability
  print "simulation probability estimation = ", result.getProbabilityEstimate()

  # Display the variance of the simulation probability estimator
  print "Variance of the simulation probability estimator = ", result.getVarianceEstimate()

  # Display the confidence interval length centered around the
  # MonteCarlo probability MCProb
  # IC = [Probability - 0.5*length, Probability + 0.5*length]
  # level 0.95
  length95 = result.getConfidenceLength(0.95)
  print "0.95 Confidence Interval length = ", length95
  print "IC at 0.95 = [", probability - 0.5*length95, "; ", probability + 0.5*length95, "]"

  # Draw the convergence graph and the confidence interval of level alpha
  # By default, alpha = 0.95
  alpha = 0.90
  convergenceGraph = myAlgo.drawProbabilityConvergence(alpha)

  # Impose a bounding box : x-range and y-range
  # boundingBox = [xmin, xmax, ymin, ymax]
  myBoundingBox = NumericalPoint( (xmin, xmax, ymin, ymax) )
  convergenceGraph.setBoundingBox(myBoundingBox)

  # In order to see the graph without creating the associated files
  Show(convergenceGraph)

  # Create the files i all formats
  convergenceGraph.draw("convergenceGraphe")

  # View the PNG file within the TUI
  ViewImage(convergenceGraph.getBitmap())

  # Get the numerical samples of the input and output random vectors
  # stored according to the History Strategy specified
  # and used to evaluate the probability estimator and its variance
  inputSampleStored = limitStateFunction.getInputHistory().getSample()
  outputSampleStored = limitStateFunction.getOutputHistory().getSample()

  # Get the values of the estimator and its variance
  # stored according to the History Strategy specified
  # and used to draw the convergence graph
  estimator_probability_sample = myAlgo.getConvergenceStrategy().getSample()[0]
  estimator_variance_sample = myAlgo.getConvergenceStrategy().getSample()[1]
\end{lstlisting}
