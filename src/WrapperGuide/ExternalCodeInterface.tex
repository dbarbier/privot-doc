% Copyright (c)  2005-2009  EDF-EADS-PHIMECA.
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts.  A copy of the license is included in the section entitled "GNU
% Free Documentation License".

In the process of externalization of the computational code relatively to the wrapper, using an external code is the final step. It will address issues that were supported, until now, by statically linking the Function with the wrapper's code and that were therefore ignored. These issues include transmitting the variables' values to the code, using files or executing the command launching the computational code.

\subsection{Transmitting values to the code}

In the examples described so far, the variables' values were transmitted to the computational code through the arguments of the function called in the wrapper, whether this function be written in C or FORTRAN. This transfer was entirely supported by the compiler as long as the wrapper's developer had properly indicated the number, type and order of the variables to supply.

When the code is completely external to the \OT\ platform, this mechanism cannot be generated by the compiler and one ends up having to manage many problems that were previously hidden:
\begin{itemize}
\item where must the variables be written so that the external code can read them?
\item in which format should they be produced (text, binary, different format)?
\item how many times does each variable appear?
\end{itemize}

However the vast majority of the computational codes we deal with use variables whose values are recorded in text format data files. The wrapper's library contains a set of predefined functions that can recognize and replace the values of these variables in text files.

There are many variables placed within binary files---e.g. mesh nodes or node fields---but the fact that this type of data is difficult to read, as well as the specific navigation and locating within these files, explain that they are not taken into account in the current version of \OT. No other format is currently taken into account.

There are also computational codes for which some values may be transmitted over the command line. \OT\ is also able to handle this situation. In this case, the only acceptable format is the text format.

The substitution mechanism for variables in files or on the command line can handle the presence of several variables, or even of the same variable several times. However, in the current state of things, the same variable can only be written in one format. This means that, for example, if a variable appears twice in the same file in two different formats, it can be recognized at both locations but it will be rewritten following a single format. This scenario is quite rare, it is currently not possible to distinguish two rewriting formats for the variable.

In summary, the mechanism of value transmission to the computational code is currently based on files or command lines in text format. Future developments may bring \OT\ to support new file formats%\footnote{Particularly HDF and MED formats.}.

\subsection{Regular expressions}

\subsubsection{General}

In the perimeter we have defined, the problem we are faced with is to identify and replace any variable, regardless of how it appears in the file or the command line. If we take the example of a physical variable, e.g. the pressure {\bf P}, placed in the input data file for a computational code, this variable may appear in very different formats:
\lstset{language=C++, basicstyle=\normalsize}
\begin{lstlisting}[frame=TBRL]
  # temperature
  T = 293 K
  # pressure
  P = 101300 Pa
  # output
  D = 1.5 l/s
\end{lstlisting}

or
\lstset{language=C++, basicstyle=\normalsize}
\begin{lstlisting}[frame=TBRL]
  293 101300 1.5
\end{lstlisting}

or else
\lstset{language=C++, basicstyle=\normalsize}
\begin{lstlisting}[frame=TBRL]
  293 1.013e5 1.5
\end{lstlisting}

\OT\ can not force the computational codes with which it wishes to interface to change the format they use for writing data. It is thus necessary to use a technique that allows to recognize the value in (almost) all cases, at least the most common ones.

Regular expressions were designed to reach this goal and they are commonly present on all current platforms%\footnote{At least on Unix/Linux systems.}. Without going into detail on the implementation of\index{regular expressions} regular expressions, which would take us outside the scope of this document and certainly towards considerations far too technical, it is nonetheless clear that the value recognition is based on a grammar. This term, which may be a bit of jargon for the computer layman, only indicates that the recognition technique relies on describing the nature of what must be identified, not what is actually written in the file. An example is more explicit.

Suppose that, in the following example:
\lstset{language=C++, basicstyle=\normalsize}
\begin{lstlisting}[frame=TBRL]
  # temperature
  T = 293 K
  # pressure
  P = 101300 Pa
  # output
  D = 1.5 l/s
\end{lstlisting}

we try to extract the value of the pressure {\bf P} to substitute a value calculated by \OT. We could search for the value {\bf 101300} in the file, but this assumes that one knows the value in advance. This approach is valid if the data file changes little or not, and if the value appears only once in the file.

If the value appears multiple times or if the file is regularly modified, or automatically generated, identifying {\bf 101300} no longer works.

In reality, what we want, as a user, is to change the numerical value that is written on the line {\bf P = <numerical value> Pa}. Regular expressions allow to describe this line in a shorter form%\footnote{The shortcuts \textbackslash R, \textbackslash I and \textbackslash S are specific to \OT\ and are not part of any standard.}:
\lstset{language=C++, basicstyle=\normalsize}
\begin{lstlisting}[frame=TBRL]
  ^P = \R Pa$
\end{lstlisting}

We find the expected terms {\bf P =} and {\bf Pa}, which frame a particular symbol {\bf \textbackslash R}. This means that, at this spot, there must be a {\bf real} numerical value. The two characters \verb+^+ and \verb+$+ respectively indicate the beginning and the end of the line.

Translated into natural language, the \index{regular expression}regular expression above can be read as \emph{find a string starting at the beginning of the line} (\verb+^+), \emph{exactly followed by the string {\bf P = }, then by a real numerical value, then by the string {\bf Pa} and ending at the end of the line} (\verb+$+).

It is then possible to find the value {\bf 101300} previously searched without knowing the value itself but only by describing how to find it using its structure (it is a numerical value) and its context (the strings {\bf P = } and {\bf Pa}).

The symbol {\bf \textbackslash R} can recognize any writing format for real numerical values, whether they are written as integers ({\bf 101300}) or floating points ({\bf 101300.0}, {\bf +1.013e+5}, etc.).

We can further improve the system by indicating that the whitespaces located between the character {\bf P} and the character {\bf =}, or anywhere elsewhere, may actually be whitespaces, tabs or any other character considered as a whitespace in a text file. This is done by replacing the whitespace with the symbol {\bf \textbackslash S}, for separator (or space). The expression is then written:

\lstset{language=C++, basicstyle=\normalsize}
\begin{lstlisting}[frame=TBRL]
  ^P\S=\S\R\SPa$
\end{lstlisting}

But it is common to place any number of whitespaces in the file, if only for readability or alignment. We can then specify that these (or any other character) is present in variable numbers. To achieve this, we have at our disposal five modifiers to set after the symbol or character considered:
\begin{itemize}
\item modifier {\bf *} indicates that this character may be repeated zero or N times;
\item modifier {\bf +} indicates that this character may be repeated once or N times;
\item modifier {\bf ?} indicates that this character may be repeated zero time or once;
\item modifier {\bf \{N\} } indicates that this character may be repeated N times;
\item modifier {\bf \{N,P\}} indicates that this character may be repeated between N and P times.
\end{itemize}

In this case the expression becomes:
\lstset{language=C++, basicstyle=\normalsize}
\begin{lstlisting}[frame=TBRL]
  ^\S*P\S*=\S*\R\S*Pa\S*$
\end{lstlisting}

which allows us to identify the value in a file such as this one:
\lstset{language=C++, basicstyle=\normalsize}
\begin{lstlisting}[frame=TBRL]
  # pressure
  P    = 101300 Pa
\end{lstlisting}

as well as this one:
\lstset{language=C++, basicstyle=\normalsize}
\begin{lstlisting}[frame=TBRL]
  # pressure
  P=101300Pa
\end{lstlisting}

Note that we have added {\bf \textbackslash S} symbols at the beginning and at the end of the line, in order to detect whitespaces at the beginning and at the end of the line.

\small
\begin{quote}
  \textit{Note: In addition to the symbol {\bf \textbackslash R}, there is also the symbol {\bf \textbackslash I} used to detect integers. All three symbols {\bf \textbackslash R}, {\bf \textbackslash S} and {\bf \textbackslash I} are specific to the \index{regular expressions}regular expressions library of \OT.}
\end{quote}
\normalsize

The entire standard grammar for extended regular expressions is available, which means that we have the following features:
\begin{itemize}
\item parentheses ( ) are used to group symbols into larger expressions and treat each term as a symbol in its own right (with its modifiers, etc.);
\item the symbol | acts as a logical OR between two terms;
\item brackets [ ] provide a list of characters (but not symbols) that can appear at one point.
\end{itemize}

Parentheses have an additional function. When a symbol, character or an expression involving symbols, characters and modifiers is set between parentheses, the value identified during reading is stored and can be used later. We will see later on that the value can be retrieved using the symbol {\bf \textbackslash nnn}, where nnn is a positive integer (nnn = 1, 2, 3 ...) designating the parentheses group in question in the expression. The groups are numbered from left to right in order of their appearance.

Thus to retrieve the numerical value of the pressure in the file, we can use the following regular expression:
\lstset{language=C++, basicstyle=\normalsize}
\begin{lstlisting}[frame=TBRL]
  ^\S*P\S*=\S*(\R)\S*Pa\S*$
\end{lstlisting}

The value will be placed in the symbol {\bf \textbackslash 1}.

As an exercise, if the data file was presented in the following format:
\lstset{language=C++, basicstyle=\normalsize}
\begin{lstlisting}[frame=TBRL]
  293 1.013e5 1.5
\end{lstlisting}
we would have recovered the temperature, pressure and flow using the following regular expression:
\lstset{language=C++, basicstyle=\normalsize}
\begin{lstlisting}[frame=TBRL]
  ^\S*(\R)\S+(\R)\S+(\R)\S*$
\end{lstlisting}

respectively in the symbols {\bf \textbackslash 1}, {\bf \textbackslash 2} and {\bf \textbackslash 3}. Note the use of the + modifiers to separate the numerical values by spaces of variable size.

\subsubsection{Implementation in the \index{description file}description file}

\index{regular expressions}Regular expressions allowing to locate the variable containing the pressure and temperature are declared in the {\bf <regexp>} tags of each variable. Each string matching the regular expression is then replaced by the content of the {\bf <format>} tag of the associated variable. This tag contains a string with one (and only one) descriptor {\bf \%E}, {\bf \%F} or {\bf \%G} (or {\bf \%e}, {\bf \%f}, {\bf \%g}) allowing to rewrite the numerical value of the variable with the decimal format expected by the external code. For a complete description of these format descriptors, please refer to the Unix man page for {\bf printf}.

But developers used to programming in C or \index{FORTRAN}FORTRAN will recognize classic formats they are accustomed to. With the example of the pressure variable P, the string identified in the data file(s) using the regular expression will be replaced by the string contained in the format. For example, for a format {\bf \%20.16G}, the value of P will be written in 20 characters, including 16 decimals.

\small
\begin{quote}
  \textit{Note: Note that it is essential to provide the code with the maximum number of decimals that it can read (and that \OT\ can produce) so as not to hinder the convergence of internal algorithms. Similarly, the computational code should produce values with maximum accuracy.}
\end{quote}
\normalsize

In summary, if we were to substitute the values of pressure and temperature in the file described above, we would write variables in the wrapper's description file as follows:

\lstset{language=XML, basicstyle=\normalsize}
\begin{lstlisting}[frame=TBRL]
  <variable-list>
  <variable id="P" type="in">
  <name>Pressure</name>
  <unit>Pa</unit>
  <regexp>^\S*P\S*=\S*\R\S*Pa\S*$</regexp>
  <format>P = %20.16G Pa</format>
  </variable>
  <variable id="T" type="in">
  <name>Temperature</name>
  <unit>K</unit>
  <regexp>^\S*T\S*=\S*\R\S*K\S*$</regexp>
  <format>T = %20.16G K</format>
  </variable>
  </variable-list>
\end{lstlisting}

\subsection{Isolating executions}

We saw in Section 3.3 that the \index{wrapper}wrapper functions could be called in parallel by multiple \index{execution}execution threads. This meant that the static and global variables were prohibited in the wrapper code%\footnote{At least, it is necessary to protect them with critical sections, but this strongly reduces the code parallelism.} because, as shared resources, they can cause access conflicts.

This problem arises again outside of the wrapper and the \OT\ platform. Indeed, a careless design of the call to the external code may result in conflicts over access to the directories and to the code data files which then become shared resources.

Let's take the example of a computational code called {\bf Code\_X}, which reads a {\bf fich.dat} input file and produces a {\bf fich.res} result file in the working directory from which it is launched. Let's also assume that the code is simultaneously launched in the same directory: both instances of {\bf Code\_X} each produce a result file bearing the same name, in the same directory. Both files risk being corrupted and unreadable.

Similarly, if the input file is generated by the wrapper of {\bf Code\_X}, and if this wrapper is called in parallel, two files with different values will be produced in the same place. Again, the access conflict will cause corruption of the file contents.

The solution is to either rename the files so that each has a different name, or to write the files in different directories and launch each computation in one directory. The first solution is usually impossible to implement because the computational codes generally read files with specific names that cannot be changed. Accordingly, we adopted the second choice in \OT. This assumes that the computational code can be run from any directory. There are few codes that do not allow this and it is always possible to recreate in the directory the environment they require.

We must also be careful here to create directories with unique names. Fortunately, the operating system offers standard features to perform this kind of operation. However, changing directories within the wrapper using the library function \index{changeDirectory}{\bf changeDirectory} changes the working directory of all wrapper threads and destroys the parallelism. It is therefore advisable to avoid using this function starting from version 0.12.2. It is preferable to use the \index{runInsulatedCommand}{\bf runInsulatedCommand} function that performs the isolation without any disruption.
\ \\
\ \\
\fbox{
  \begin{minipage}{1\textwidth}
    \begin{center}
      {\bf The \emph{ChangeDirectory} function is obsolete and should no longer be used.}
    \end{center}
  \end{minipage}
}
\ \\
\OT\ provides library functions to help write the wrapper:
\begin{itemize}
\item the \index{getCurrentWorkingDirectory}{\bf getCurrentWorkingDirectory()} function returns a string containing the name of the current execution directory. The returned string must be freed by the caller.
\item the \index{createTemporaryDirectory}{\bf createTemporaryDirectory(prefix, p\_exchangedData)} function creates a temporary directory with a unique name and returns this name in a string. The directory is created in the {\bf temporary-directory}, declared in the \index{installation directory}{\bf <openturns\_dir>/etc/openturns.conf}, prefixed with the {\bf prefix} string.
\item the \index{deleteTemporaryDirectory}{\bf deleteTemporaryDirectory(tempDir, status)} deletes the temporary directory and its content if {\bf status} has a non-zero value. {\bf status} is usually the value returned by {\bf runInsulatedCommand}, thus any execution error in the solver will allow to keep the files. The string {\bf tempDir} is systematically deleted even if {\bf status} is non-zero.
\end{itemize}

\subsection{Transmission via files}

The vast majority of external codes use files to communicate the input and output values for the computational code. Values are most often written as text (ASCII or equivalent) that can be modified either by user or by peripheral data tools. This is how physical or numerical parameters are transmitted for the computation.

It also happens that some codes use binary files to speed up and simplify the reading of complex data. This also significantly reduces the file size when there is a sizeable volume of data: mesh and CAD files are typically an example of binary files. We may also want to use this file format to retain maximum numerical precision on the data because no truncation or alteration happens during writing or reading.

As it stands, the \index{substitution}substitution mechanism based on \index{regular expressions}regular expressions can only work on text files. This is currently a limitation of the interfacing mechanism between external codes and \OT, since it is not possible to read or write a probabilistic variable in binary files.

All files manipulated by the external code that must be processed by the wrapper, whether it be a copy in the temporary directory and/or variable substitution, must be declared in the {\bf <data>} tag of the description file as follows:

\lstset{language=XML, basicstyle=\normalsize}
\begin{lstlisting}[frame=TBRL]
  <external-code>
  <data>
  <!-- An input file -->
  <file id="data" type="in">
  <name>The input data file</name>
  <path>code_C1.data</path>
  </file>

  <!-- An output file -->
  <file id="result" type="out">
  <name>The output result file</name>
  <path>code_C1.result</path>
  </file>

  </data>
  ...
  </external-code>
\end{lstlisting}

This example shows how to declare a data file---of type {\bf in}---and a result file---of type {\bf out}. Data files are intended to be copied into the temporary directory because they will be modified before the computation begins. However, if the input files are never modified, we can get rid of the copy as long as the computation procedure, which will be launched by \OT, knows where to find them. The result files are not copied in the initial directory%\footnote{The directory where the \OT\ library works, which is generally the one from which the script or the graphical interface was launched.}, because the high number of potential executions of the computational code could saturate the disk space. The other problem is that these files generally bear the same name. It then becomes difficult to name each one so as to distinguish it from the others%\footnote{One can, of course, use a suffix with a number, but this does not give much more information about the content of the file.}.

Each file must bear a unique identifier ({\bf id}), a type ({\bf in} or {\bf out}). It may also have a name ({\bf name}) that only serves as a commentary for users.

The path ({\bf path}) is used to determine the location of the file relatively to the current directory where the wrapper is being run. This path can be relative or absolute. During the process of copying files in the temporary directory, no name substitution is possible. The file will thus be copied with the same name.

There is no limit on the number of input or output files.

Before version 0.12.2, data or result files were systematically read in order to substitute or read probabilistic variables. Occasionnally, however, some files could not be read, for example binary files, without causing an error. Therefore, version 0.12.2 introduces an additional tag called {\bf <subst>}, indicating which variable is in which file. Only files declaring a non-empty {\bf <subst>} tag will be read in search of variables. The variables appearing in the {\bf <subst>} tag must be separated by commas without any other delimiter (whitespace or tab).

The following example shows how to declare the input variables ({\bf P} and {\bf T}) and output variables ({\bf O1} and {\bf O2}) in the files:

\lstset{language=XML, basicstyle=\normalsize}
\begin{lstlisting}[frame=TBRL]
  <external-code>
  <data>
  <!-- An input file -->
  <file id="data" type="in">
  <name>The input data file</name>
  <path>code_C1.data</path>
  <subst>P,T</subst>
  </file>

  <!-- An output file -->
  <file id="result" type="out">
  <name>The output result file</name>
  <path>code_C1.result</path>
  <subst>O1,O2</subst>
  </file>

  </data>
  ...
  </external-code>
\end{lstlisting}

To easily perform the variable substitution and the file copy within the wrapper, \OT\ offers several library functions:
\begin{itemize}
\item the \index{createInputFiles}{\bf createInputFiles(tempDir, p\_exchangedData, p\_point)} function copies all the input files declared in the description file (whose content is carried by the {\bf p\_exchangedData} structure) in the temporary directory {\bf tempDir} by substituting the variable values contained in {\bf p\_point};
\item the \index{readOutputFiles}{\bf readOutputFiles (tempDir, p\_exchangedData, p\_point)} function reads the content of the variables in the result files declared in the description file (whose content is carried by the {\bf p\_exchangedData} structure) and present in the temporary directory {\bf tempDir}, and stores the values in {\bf p\_point}.
\end{itemize}

\subsection{Transmission using command line arguments}

In some rare cases, solvers require that the values of some variables be passed using command line options. \OT\ is able to carry out the same kind of \index{substitution}substitution from a model command line defined in the wrapper's \index{description file}description file ({\bf <command>} tag). All that is needed is to create a pseudo-command line in which the values of variables appear in a form that can be detected by a \index{regular expressions}regular expression, and to proceed with the variable substitution ({\bf <regexp>} and {\bf <format>} tags) in a conventional manner.

The following example shows how to substitute the {\bf P} variable on the command line:

\lstset{language=XML, basicstyle=\normalsize}
\begin{lstlisting}[frame=TBRL]
  <variable-list>
  <variable id="P" type="in">
  <name>Pression</name>
  <unit>Pa</unit>
  <regexp>%:P:%</regexp>
  <format>%20.16G</format>
  </variable>
  ...
  </variable-list>
  ...
  <external-code>
  <data>
  <!-- NO input file -->
  <!-- An output file -->
  <file id="result" type="out">
  <name>The output result file</name>
  <path>code_C1.result</path>
  <subst>O1,O2</subst>
  </file>
  </data>
  ...
  <command>/here/is/myCode --someoption P=%:P:%</command>
  </external-code>
\end{lstlisting}

The string \%:P:\%, very characteristically chosen, simply identifies the location of the substitution on the command line. It will be replaced by the value of variable in the \%20.16G format as described in the {\bf format} tag.

For the substitution to take place on the command line, we must explicitly call the library function \index{runInsulatedCommand}{\bf runInsulatedCommand(tempDir, p\_exchangedData, p\_point)} which requires the same parameters as the {\bf createInputfiles} function seen in the previous section.

\subsection{Writing an execution function for an external code}

We saw in Section 4.4.5 that the execution function could be simplified to: (v. 0.12.2 and after)
\index{macro}
\lstset{language=C++, basicstyle=\normalsize}
\begin{lstlisting}[frame=TBRL]
  FUNC_EXEC( WRAPPERNAME ,
  {
    /* Instructions carrying out the computation */
  } )
\end{lstlisting}

But we have not yet given an explicit content to this function. With the elements that have been presented in this section, it is now possible to describe what must be done in order to correctly call an external code.

\lstset{language=C++, basicstyle=\normalsize}
\begin{lstlisting}[frame=TBRL]
  FUNC_EXEC( WRAPPERNAME ,
  {
    struct WrapperExchangedData * p_exchangedData =
    CAST(struct WrapperExchangedData * , p_state);
    int rc = 0;
    char * temporaryDirectory = 0;
    char * cmd = 0;
    char * currentWorkingDirectory = 0;

    /* We save the current working directory for a future come back */
    currentWorkingDirectory = getCurrentWorkingDirectory();

    /* We build a temporary directory in which we will work */
    temporaryDirectory = createTemporaryDirectory( "myPrefix", p_exchangedData);

    /* We create the external code's input files in the temporary directory */
    if (createInputFiles(temporaryDirectory, p_exchangedData, inPoint))
    return WRAPPER_EXECUTION_ERROR;

    /* The real computation is here */
    rc = runInsulatedCommand(temporaryDirectory, p_exchangedData, inPoint);

    /* Read the output values */
    if ( !rc )
    if (readOutputFiles(temporaryDirectory, p_exchangedData, outPoint))
    return WRAPPER_EXECUTION_ERROR;

    /* We kill the temporary directory if no error has occured */
    deleteTemporaryDirectory(temporaryDirectory, rc);

    free ( currentWorkingDirectory );
  }
\end{lstlisting}

Note that the heart of function is completely independent from the code that is being driven, with the exception of the prefix name for the temporary directory. That is why this function can be further simplified as:

\lstset{language=C++, basicstyle=\normalsize}
\begin{lstlisting}[frame=TBRL]
  FUNC_EXEC( WRAPPERNAME ,
  FUNC_EXEC_BODY_CALLING_COMMAND_IN_TEMP_DIR( "myPrefix" ) )
\end{lstlisting}

\subsection{Sharing the \index{internal state}internal state}

So far, the examples we have shown used what we called the "internal state" to store a data structure corresponding to the content of the wrapper's \index{description file}description file. This data structure was accessible through the {\bf p\_exchangedData} pointer.

We recall that the internal state can be accessed via a pointer named {\bf p\_state}, passed as argument to (almost) all functions of the wrapper. The information it contains is created within the {\bf createState\_} function but is retained by the \OT\ library which is responsible for transmitting the pointer to each function call. The state plays the role of a static (or global) variable for the wrapper's functions, when this type of variable is prohibited.

Thus this internal state is the ideal place to store information that must be persistent from one call of the wrapper's functions to the next. It is quite possible to compute a piece of data in the {\bf getInfo\_} function, store it in the internal state which will be passed to the {\bf exec\_} function which then uses it.

We can also compute a value within the {\bf exec\_} function, store it in the internal state for the next call to this same {\bf exec\_} function. However, we must always bear in mind that the wrapper's functions, especially functions such as {\bf exec\_} or \index{exec\_sample\_}{\bf exec\_sample\_}, may be called in parallel by the \OT\ library. Therefore they must be designed to be reentrant and multithread-safe.

In the most common mode, the internal state is only shared within the wrapper functions corresponding to the same block, that is to say the same Function, the same Gradient or the same Hessian. This means that, by default, the internal state of the \index{Function}Function is completely different and disjoint from the internal state of the \index{Gradient}Gradient and of the \index{Hessian}Hessian. This is what we call the {\bf specific} mode in the wrapper settings.

However, it is possible to combine these three internal states into one, which will be common to all three blocks Function, Gradient and Hessian. It is the {\bf shared} mode in the wrapper settings. The internal state will be created and deleted by the {\bf createState\_} and {\bf deleteState\_} functions of the Function, and then passed as an argument to all the functions of all blocks. Again, we must be careful about concurrent access to the data contained therein. However, we must notice that the {\bf createState\_} and {\bf deleteState\_} functions of the Gradient and the Hessian will not be called at all.

Whichever mode gets chosen, the \OT\ library ensures that the internal state will not be moved or relocated elsewhere in memory, which guarantees that the passed pointer may be accessed for reading without any special protection. However, any writing (and corresponding reading) must be protected.

Why share the internal state? When calling one block (for example the Function), some codes compute data related to another block (for example the Gradient). The shared internal state allows to store this information, which is unnecessary for the first block, so as to be used by the second block without being computed again. This saves considerable time and helps achieve a better accuracy on certain treatments.

We do not offer an example of shared internal state because situations are so varied and complex that a general solution is usually of little practical use. However, any wrapper developer with a good command of multithreaded and C programming can get by with this scenario without too much trouble.
